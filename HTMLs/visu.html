<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VISU</title>
<style>
    /* * VISU - Orthogonal Audio Visualizer
     * License: ISC
     */
    :root {
        --bg: #050505;
        --fg: #00FF99;
        --accent: #FF0055;
        --font: 'Courier New', monospace;
    }

    body {
        margin: 0;
        overflow: hidden;
        background-color: var(--bg);
        color: var(--fg);
        font-family: var(--font);
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        user-select: none;
    }

    canvas {
        display: block;
        box-shadow: 0 0 20px rgba(0, 255, 153, 0.1);
    }

    /* --- Overlay / Menu --- */
    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(5, 5, 5, 0.95);
        z-index: 10;
        transition: opacity 0.3s;
    }

    #overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }

    h1 {
        margin-bottom: 40px;
        text-shadow: 0 0 10px var(--fg);
    }

    .menu {
        display: flex;
        flex-direction: column;
        gap: 20px;
        min-width: 300px;
    }

    button, .input-zone {
        background: transparent;
        color: var(--fg);
        border: 2px solid var(--fg);
        padding: 15px 20px;
        font-family: var(--font);
        font-size: 16px;
        cursor: pointer;
        text-transform: uppercase;
        transition: all 0.2s;
        text-align: center;
    }

    button:hover, .input-zone:hover {
        background: var(--fg);
        color: var(--bg);
        box-shadow: 0 0 15px var(--fg);
    }

    .input-zone {
        border-style: dashed;
        display: block;
    }

    /* --- HUD --- */
    .status {
        position: absolute;
        top: 10px; left: 10px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        pointer-events: none;
        font-size: 14px;
        z-index: 5;
    }

    .controls-hint {
        position: absolute;
        bottom: 10px; right: 10px;
        font-size: 12px;
        opacity: 0.7;
        text-align: right;
        pointer-events: none;
    }

    /* --- Audio Player Controls --- */
    #player {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid var(--fg);
        padding: 10px;
        display: none; /* Hidden by default */
        z-index: 8;
    }

    #player.active {
        display: block;
    }

    #trackName {
        text-align: center;
        font-size: 12px;
        color: var(--accent);
        margin-bottom: 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .progress-container {
        width: 100%;
        height: 10px;
        background: #111;
        cursor: pointer;
        margin-bottom: 8px;
        position: relative;
    }

    .progress-fill {
        height: 100%;
        background: var(--fg);
        width: 0%;
        pointer-events: none;
    }

    .progress-tooltip {
        position: absolute;
        top: -30px;
        background: var(--bg);
        color: var(--fg);
        border: 1px solid var(--fg);
        padding: 4px 6px;
        font-size: 11px;
        pointer-events: none;
        display: none;
        white-space: nowrap;
        transform: translateX(-50%);
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }

    .progress-container:hover .progress-fill {
        background: var(--accent);
    }
    
    .progress-container:hover .progress-tooltip {
        display: block;
    }

    .player-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
    }

    .player-btns button {
        border: none;
        padding: 5px 10px;
        font-size: 18px;
        min-width: 40px;
    }
    
    .player-btns button:hover {
        box-shadow: none;
        text-shadow: 0 0 5px var(--fg);
    }

    input[type="file"] { display: none; }
</style>
</head>
<body>

<div id="overlay">
    <h1>VISU</h1>
    <div class="menu">
        <button id="btn-capture">[ CAPTURE SYSTEM / TAB ]</button>
        <button id="btn-mic">[ MICROPHONE ]</button>
        <div class="input-zone" id="dropZone">
            [ DRAG AUDIO FILE HERE ]<br>
            <span style="font-size: 0.8em; opacity: 0.8;">OR CLICK TO BROWSE</span>
        </div>
    </div>
    <input type="file" id="fileInput" accept="audio/*">
</div>

<div class="status" id="statusLine">Mode 0: Spectrum</div>
<div class="controls-hint">TAB: Next Mode | Q: Stop</div>

<!-- Player UI -->
<div id="player">
    <div id="trackName">No File Playing</div>
    <div class="progress-container" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
        <div class="progress-tooltip" id="progressTooltip">00:00</div>
    </div>
    <div class="player-row">
        <span id="currTime">00:00</span>
        <div class="player-btns">
            <button id="btnSeekBack">&lt;&lt;</button>
            <button id="btnPlayPause">||</button>
            <button id="btnSeekFwd">&gt;&gt;</button>
        </div>
        <span id="totalTime">00:00</span>
    </div>
</div>

<canvas id="cvs"></canvas>

<script>
/**
 * config.js - Runtime Configuration
 */
const CONFIG = {
    WIN_W: 1200,
    WIN_H: 800,
    FFT_SIZE: 2048,
    SMOOTHING: 0.3,
    AMP_SCALE: 1.5,
    COLOR_BG: [5, 5, 5],
    COLOR_FG: [0, 255, 153],
};

/**
 * visu.js - Application Core
 */
const APP = {
    ctx: null,
    canvas: null,
    audioCtx: null,
    analyser: null,
    source: null,
    audioElement: null, // Only used for File mode
    dataArray: null,
    timeArray: null,
    rafId: null,
    mode: 0,
    frameCount: 0,
    running: false,
    width: CONFIG.WIN_W,
    height: CONFIG.WIN_H,
    imageData: null,
    buf32: null, 
};

// --- Visualization Modes ---
const MODES = [
    { name: "Spectrum", fn: draw_spectrum },
    { name: "Oscilloscope", fn: draw_oscilloscope },
    { name: "Radial Burst", fn: draw_radial },
    { name: "Circular Spectrum", fn: draw_circular_spectrum },
    { name: "Psychedelic Ripple", fn: draw_psychedelic_ripple, pixel: true },
    { name: "Matrix Rain", fn: draw_matrix_rain },
    { name: "Spiral Galaxy", fn: draw_spiral },
    { name: "Tunnel Vision", fn: draw_tunnel, pixel: true },
    { name: "Frequency Mandala", fn: draw_mandala },
    { name: "Strange Attractor", fn: draw_strange },
    { name: "Plasma Field", fn: draw_plasma, pixel: true },
    { name: "Starfield", fn: draw_starfield },
    { name: "Retro Terrain", fn: draw_terrain }
];

// --- Math & Color ---
const PI = Math.PI;
const TWO_PI = Math.PI * 2;

function hsv_to_rgb(h, s, v) {
    let r, g, b, i, f, p, q, t;
    i = Math.floor(h / 60);
    f = h / 60 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }
    return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
}

function formatTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "00:00";
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// --- Drawing Functions ---

function draw_spectrum() {
    const n_bars = 100;
    const w = APP.width / n_bars;
    const len = APP.analyser.frequencyBinCount;
    for (let i = 0; i < n_bars; i++) {
        let idx = Math.floor(Math.pow(i / n_bars, 2.0) * len);
        let val = APP.dataArray[idx] * CONFIG.AMP_SCALE; 
        if (val > APP.height) val = APP.height;
        let r = val / 2, g = 255 - val / 4, b = 150;
        APP.ctx.fillStyle = `rgba(${r},${g},${b},1)`;
        APP.ctx.fillRect(i * w, APP.height - val, w - 1, val);
    }
}

function draw_oscilloscope() {
    APP.analyser.getFloatTimeDomainData(APP.timeArray);
    APP.ctx.lineWidth = 2;
    APP.ctx.strokeStyle = `rgb(0, 255, 100)`;
    APP.ctx.beginPath();
    const sliceWidth = APP.width / APP.timeArray.length;
    let x = 0;
    for (let i = 0; i < APP.timeArray.length; i++) {
        const v = APP.timeArray[i] * 0.5 + 0.5;
        const y = v * APP.height;
        if (i === 0) APP.ctx.moveTo(x, y); else APP.ctx.lineTo(x, y);
        x += sliceWidth;
    }
    APP.ctx.stroke();
}

function draw_radial() {
    const cx = APP.width / 2, cy = APP.height / 2;
    const n = 120, len = APP.analyser.frequencyBinCount;
    for (let i = 0; i < n; i++) {
        let idx = i * 2; if (idx >= len) idx = len - 1;
        let amp = APP.dataArray[idx] * CONFIG.AMP_SCALE * 0.8;
        if (amp > 300) amp = 300;
        let a = (TWO_PI * i) / n;
        APP.ctx.strokeStyle = `rgb(255, ${50 + amp}, 50)`;
        APP.ctx.lineWidth = 2;
        APP.ctx.beginPath();
        APP.ctx.moveTo(cx + Math.cos(a) * 100, cy + Math.sin(a) * 100);
        APP.ctx.lineTo(cx + Math.cos(a) * (100 + amp), cy + Math.sin(a) * (100 + amp));
        APP.ctx.stroke();
    }
}

function draw_circular_spectrum() {
    const cx = APP.width / 2, cy = APP.height / 2;
    const n = 180, len = APP.analyser.frequencyBinCount;
    for (let i = 0; i < n; i++) {
        let idx = Math.floor((i * len) / n);
        let amp = APP.dataArray[idx] * 0.8;
        if (amp > 250) amp = 250;
        let a = (TWO_PI * i) / n;
        let r = 150 + amp;
        let c = hsv_to_rgb((i * 360) / n, 0.9, 1.0);
        APP.ctx.fillStyle = `rgb(${c.r}, ${c.g}, ${c.b})`;
        APP.ctx.fillRect(cx + Math.cos(a) * r, cy + Math.sin(a) * r, 3, 3);
    }
}

function draw_psychedelic_ripple() {
    const time = APP.frameCount * 0.02;
    const cx = APP.width / 2, cy = APP.height / 2;
    const len = APP.analyser.frequencyBinCount;
    const buf = APP.buf32, w = APP.width, h = APP.height;
    for (let y = 0; y < h; y += 4) {
        for (let x = 0; x < w; x += 4) {
            let dx = (x - cx) / 200.0, dy = (y - cy) / 200.0;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let idx = Math.floor(dist * 20) % len;
            let val = Math.sin(dist * 5.0 - time + (APP.dataArray[idx]/100.0) * 3.0);
            let c = hsv_to_rgb((dist * 100 + time * 50) % 360, 0.8, (val + 1) / 2);
            const p = (255 << 24) | (c.b << 16) | (c.g << 8) | c.r;
            for(let by=0; by<4; by++) {
                if (y+by >= h) break;
                for(let bx=0; bx<4; bx++) {
                    if (x+bx >= w) break;
                    buf[(y+by)*w + (x+bx)] = p;
                }
            }
        }
    }
}

function draw_matrix_rain() {
    const cols = 60, cw = APP.width / cols;
    const len = APP.analyser.frequencyBinCount;
    for (let i = 0; i < cols; i++) {
        let idx = Math.floor((i * len) / cols);
        let drops = Math.floor((APP.dataArray[idx] / 150.0) * 40);
        for (let j = 0; j < drops; j++) {
            let y = Math.floor(APP.frameCount * 3 + j * 20 + i * 13) % APP.height;
            let a = 1.0 - (j / drops);
            APP.ctx.fillStyle = `rgba(0, 255, 100, ${a})`;
            APP.ctx.fillRect(i * cw, y, cw - 1, 2);
        }
    }
}

function draw_spiral() {
    const cx = APP.width / 2, cy = APP.height / 2;
    const t = APP.frameCount * 0.01;
    const len = APP.analyser.frequencyBinCount;
    for (let i = 0; i < 500; i++) {
        let idx = i % len;
        let amp = APP.dataArray[idx] * 0.5;
        let rad = i * 0.8 + amp;
        let ang = (i * 0.05 + t) * 0.3 + rad * 0.02;
        let c = hsv_to_rgb(((i * 0.05 + t) * 20) % 360, 0.9, 1.0);
        APP.ctx.fillStyle = `rgba(${c.r}, ${c.g}, ${c.b}, 0.8)`;
        APP.ctx.fillRect(cx + Math.cos(ang) * rad, cy + Math.sin(ang) * rad, 2, 2);
    }
}

function draw_tunnel() {
    const cx = APP.width / 2, cy = APP.height / 2;
    const t = APP.frameCount * 0.05;
    const len = APP.analyser.frequencyBinCount;
    const buf = APP.buf32, w = APP.width, h = APP.height;
    for (let y = 0; y < h; y += 3) {
        for (let x = 0; x < w; x += 3) {
            let dx = x - cx, dy = y - cy;
            let ang = Math.atan2(dy, dx), dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 1) dist = 1;
            let u = t + 100.0 / dist;
            let idx = Math.floor(ang * 10.0 + u * 5.0) % len;
            if (idx < 0) idx += len;
            let bri = (u + APP.dataArray[idx]/200.0) % 1.0;
            let c = hsv_to_rgb((ang * 57.3 + t * 10) % 360, 0.7, bri);
            const p = (255 << 24) | (c.b << 16) | (c.g << 8) | c.r;
            for(let by=0; by<3; by++) {
                if (y+by >= h) break;
                for(let bx=0; bx<3; bx++) {
                    if (x+bx >= w) break;
                    buf[(y+by)*w + (x+bx)] = p;
                }
            }
        }
    }
}

function draw_mandala() {
    const cx = APP.width / 2, cy = APP.height / 2;
    const arms = 8, len = APP.analyser.frequencyBinCount;
    for (let arm = 0; arm < arms; arm++) {
        let base = (TWO_PI * arm) / arms;
        for (let i = 0; i < 100; i++) {
            let idx = i * 3; if (idx >= len) idx = len - 1;
            let r = 50 + i * 3 + APP.dataArray[idx] * 0.6;
            let ang = base + Math.sin(i * 0.1) * 0.3;
            let c = hsv_to_rgb(i * 3.6 + arm * 45, 0.8, 1.0);
            APP.ctx.fillStyle = `rgb(${c.r}, ${c.g}, ${c.b})`;
            APP.ctx.fillRect(cx + Math.cos(ang) * r, cy + Math.sin(ang) * r, 2, 2);
        }
    }
}

const ATTR = { x: 0.1, y: 0.1 };
function draw_strange() {
    let bass = 0, mid = 0;
    for (let i = 0; i < 10; i++) bass += APP.dataArray[i];
    for (let i = 20; i < 40; i++) mid += APP.dataArray[i];
    bass /= 1000.0; mid /= 1000.0;
    let a = 1.5 + bass * 2, b = -1.8 + mid * 1.5, c = 1.6, d = 0.9;
    let x = ATTR.x, y = ATTR.y;
    for (let i = 0; i < 2000; i++) {
        let xn = Math.sin(a * y) + c * Math.cos(a * x);
        let yn = Math.sin(b * x) + d * Math.cos(b * y);
        x = xn; y = yn;
        let c_rgb = hsv_to_rgb((i * 0.36 + APP.frameCount) % 360, 0.9, 1.0);
        APP.ctx.fillStyle = `rgba(${c_rgb.r}, ${c_rgb.g}, ${c_rgb.b}, 0.6)`;
        APP.ctx.fillRect(Math.floor((x + 3) * APP.width / 6), Math.floor((y + 3) * APP.height / 6), 1, 1);
    }
    ATTR.x = x; ATTR.y = y;
}

function draw_plasma() {
    const t = APP.frameCount * 0.03;
    const len = APP.analyser.frequencyBinCount;
    const buf = APP.buf32, w = APP.width, h = APP.height;
    for (let y = 0; y < h; y += 2) {
        for (let x = 0; x < w; x += 2) {
            let fx = Math.floor((x * len) / w), fy = Math.floor((y * len) / h);
            if (fx >= len) fx = len - 1; if (fy >= len) fy = len - 1;
            let mod = (APP.dataArray[fx] + APP.dataArray[fy]) / 400.0;
            let v = Math.sin(x * 0.01 + t) + Math.sin(y * 0.01 + t * 1.3) +
                    Math.sin((x + y) * 0.008 + t * 0.7) +
                    Math.sin(Math.sqrt(x*x + y*y) * 0.01 + t * 2.0) + mod * 2.0;
            v = (v + 4.0) / 8.0;
            let c = hsv_to_rgb(v * 360, 0.8, v);
            const p = (255 << 24) | (c.b << 16) | (c.g << 8) | c.r;
            buf[y*w + x] = buf[y*w + x+1] = buf[(y+1)*w + x] = buf[(y+1)*w + x+1] = p;
        }
    }
}

// --- NEW VISUALIZATIONS ---

const STARS = Array(200).fill().map(() => ({
    x: (Math.random() - 0.5) * 2000,
    y: (Math.random() - 0.5) * 2000,
    z: Math.random() * 2000
}));

function draw_starfield() {
    const cx = APP.width / 2, cy = APP.height / 2;
    // Bass kick detection
    let bass = 0;
    for(let i=0; i<10; i++) bass += APP.dataArray[i];
    bass /= 10.0;
    
    const speed = 10 + (bass * 0.5); // Modulate speed

    APP.ctx.fillStyle = '#FFF';
    
    STARS.forEach(star => {
        star.z -= speed;
        if (star.z <= 0) {
            star.z = 2000;
            star.x = (Math.random() - 0.5) * 2000;
            star.y = (Math.random() - 0.5) * 2000;
        }

        const scale = 500 / star.z;
        const sx = cx + star.x * scale;
        const sy = cy + star.y * scale;
        const r = Math.max(0.5, scale * 3);

        if (sx > 0 && sx < APP.width && sy > 0 && sy < APP.height) {
            APP.ctx.globalAlpha = Math.min(1, scale);
            APP.ctx.beginPath();
            APP.ctx.arc(sx, sy, r, 0, TWO_PI);
            APP.ctx.fill();
        }
    });
    APP.ctx.globalAlpha = 1;
}

function draw_terrain() {
    const w = APP.width, h = APP.height;
    const cx = w / 2, cy = h / 2;
    APP.analyser.getFloatTimeDomainData(APP.timeArray);
    
    // Retro Grid
    APP.ctx.strokeStyle = '#00FF99';
    APP.ctx.lineWidth = 1;
    
    const lines = 20;
    const t = (APP.frameCount % 20) / 20; // 0 to 1
    
    // Vertical
    for(let i=-10; i<=10; i++) {
        APP.ctx.beginPath();
        // Perspective projection: Top (horizon) is narrow, Bottom is wide
        APP.ctx.moveTo(cx + i * 20, cy); 
        APP.ctx.lineTo(cx + i * 100, h);
        APP.ctx.stroke();
    }
    
    // Horizontal (Moving)
    for(let i=0; i<lines; i++) {
        let z = i + t; // 0 to 20
        let y = cy + (z / lines) * (h - cy);
        
        // Modulate y with waveform
        let waveIdx = Math.floor((i / lines) * APP.timeArray.length);
        let waveOffset = APP.timeArray[waveIdx] * 50;

        APP.ctx.beginPath();
        APP.ctx.moveTo(0, y + waveOffset);
        APP.ctx.lineTo(w, y + waveOffset);
        APP.ctx.strokeStyle = `rgba(0, 255, 153, ${i/lines})`;
        APP.ctx.stroke();
    }
}


// --- Main Loop & UI ---
function updatePlayerUI() {
    if (!APP.audioElement) return;
    
    const curr = APP.audioElement.currentTime;
    const dur = APP.audioElement.duration || 0;
    const pct = (curr / dur) * 100;
    
    document.getElementById('currTime').innerText = formatTime(curr);
    document.getElementById('totalTime').innerText = formatTime(dur);
    document.getElementById('progressFill').style.width = pct + '%';
    
    const btn = document.getElementById('btnPlayPause');
    btn.innerText = APP.audioElement.paused ? "|>" : "||";
}

function loop() {
    if (!APP.running) return;
    APP.rafId = requestAnimationFrame(loop);
    APP.analyser.getByteFrequencyData(APP.dataArray);

    if (APP.audioElement) updatePlayerUI();

    if (MODES[APP.mode].pixel) {
        APP.buf32.fill((255 << 24) | (CONFIG.COLOR_BG[2] << 16) | (CONFIG.COLOR_BG[1] << 8) | CONFIG.COLOR_BG[0]);
    } else {
        APP.ctx.fillStyle = `rgb(${CONFIG.COLOR_BG[0]}, ${CONFIG.COLOR_BG[1]}, ${CONFIG.COLOR_BG[2]})`;
        APP.ctx.fillRect(0, 0, APP.width, APP.height);
    }

    MODES[APP.mode].fn();

    if (MODES[APP.mode].pixel) APP.ctx.putImageData(APP.imageData, 0, 0);
    APP.frameCount++;
}

// --- Initialization ---
function init() {
    APP.canvas = document.getElementById('cvs');
    APP.ctx = APP.canvas.getContext('2d', { alpha: false });
    APP.canvas.width = CONFIG.WIN_W;
    APP.canvas.height = CONFIG.WIN_H;
    APP.imageData = APP.ctx.createImageData(CONFIG.WIN_W, CONFIG.WIN_H);
    APP.buf32 = new Uint32Array(APP.imageData.data.buffer);
    setupInputHandlers();
}

function startAudio(stream, isFile = false) {
    if (!APP.audioCtx) APP.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    if (APP.source) {
        // Cleanup old source if needed
        try { APP.source.disconnect(); } catch(e){}
    }
    
    // Clear old Element reference
    if (APP.audioElement && !isFile) {
        APP.audioElement.pause();
        APP.audioElement = null;
    }

    APP.analyser = APP.audioCtx.createAnalyser();
    APP.analyser.fftSize = CONFIG.FFT_SIZE;
    APP.analyser.smoothingTimeConstant = CONFIG.SMOOTHING;

    if (isFile) {
        APP.audioElement = stream; // Stream is the Audio Element here
        APP.source = APP.audioCtx.createMediaElementSource(stream);
        
        // MPRIS / Media Session Setup (Handled in handleFile for metadata, but actions here)
        if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('play', () => stream.play());
            navigator.mediaSession.setActionHandler('pause', () => stream.pause());
            navigator.mediaSession.setActionHandler('seekto', (details) => {
                 if (details.fastSeek && 'fastSeek' in stream) {
                     stream.fastSeek(details.seekTime);
                 } else {
                     stream.currentTime = details.seekTime;
                 }
            });
            navigator.mediaSession.setActionHandler('previoustrack', () => { stream.currentTime -= 10; });
            navigator.mediaSession.setActionHandler('nexttrack', () => { stream.currentTime += 10; });
        }

        document.getElementById('player').classList.add('active');
        stream.play();
    } else {
        APP.source = APP.audioCtx.createMediaStreamSource(stream);
        document.getElementById('player').classList.remove('active');
    }

    APP.source.connect(APP.analyser);
    if (isFile) APP.source.connect(APP.audioCtx.destination);

    APP.dataArray = new Uint8Array(APP.analyser.frequencyBinCount);
    APP.timeArray = new Float32Array(APP.analyser.fftSize);

    APP.running = true;
    document.getElementById('overlay').classList.add('hidden');
    loop();
}

function setupInputHandlers() {
    const btnCapture = document.getElementById('btn-capture');
    const btnMic = document.getElementById('btn-mic');
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');

    // Sources
    btnCapture.addEventListener('click', () => {
        navigator.mediaDevices.getDisplayMedia({ video: { width: 1, height: 1 }, audio: true })
        .then(stream => {
            if (stream.getAudioTracks().length === 0) { alert("No audio shared!"); return; }
            startAudio(stream, false);
        })
        .catch(console.error);
    });

    btnMic.addEventListener('click', () => {
        navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(stream => startAudio(stream, false))
        .catch(e => alert("Mic denied: " + e));
    });

    // File Input
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', function() { if (this.files.length) handleFile(this.files[0]); });
    
    // Drag & Drop
    const overlay = document.getElementById('overlay');
    overlay.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.background = 'var(--fg)'; dropZone.style.color = 'var(--bg)'; });
    overlay.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.style.background = 'transparent'; dropZone.style.color = 'var(--fg)'; });
    overlay.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.style.background = 'transparent'; dropZone.style.color = 'var(--fg)';
        if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    });

    // Player Controls
    document.getElementById('btnPlayPause').addEventListener('click', () => {
        if(APP.audioElement) APP.audioElement.paused ? APP.audioElement.play() : APP.audioElement.pause();
    });
    document.getElementById('btnSeekBack').addEventListener('click', () => {
        if(APP.audioElement) APP.audioElement.currentTime -= 10;
    });
    document.getElementById('btnSeekFwd').addEventListener('click', () => {
        if(APP.audioElement) APP.audioElement.currentTime += 10;
    });
    
    // Progress Bar Interactions
    const pBar = document.getElementById('progressBar');
    const pTooltip = document.getElementById('progressTooltip');

    pBar.addEventListener('click', (e) => {
        if(!APP.audioElement) return;
        const rect = pBar.getBoundingClientRect();
        const pct = (e.clientX - rect.left) / rect.width;
        APP.audioElement.currentTime = pct * APP.audioElement.duration;
    });
    
    pBar.addEventListener('mousemove', (e) => {
        if(!APP.audioElement) return;
        const rect = pBar.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, px / rect.width));
        
        // Tooltip Positioning
        pTooltip.style.left = px + 'px';
        
        // Time Calculation
        const time = pct * (APP.audioElement.duration || 0);
        pTooltip.innerText = formatTime(time);
    });

    // Keys
    window.addEventListener('keydown', e => {
        if (!APP.running) return;
        if (e.key === 'Tab') {
            e.preventDefault();
            APP.mode = (APP.mode + 1) % MODES.length;
            document.getElementById('statusLine').innerText = `Mode ${APP.mode}: ${MODES[APP.mode].name}`;
        }
        else if (e.key === 'q' || e.key === 'Q') {
            APP.running = false;
            if(APP.audioElement) APP.audioElement.pause();
            cancelAnimationFrame(APP.rafId);
            document.getElementById('overlay').classList.remove('hidden');
            document.getElementById('player').classList.remove('active');
        }
        else if (e.key === ' ' && APP.audioElement) {
             e.preventDefault();
             APP.audioElement.paused ? APP.audioElement.play() : APP.audioElement.pause();
        }
        else if (e.key === 'ArrowRight' && APP.audioElement) {
            APP.audioElement.currentTime += 10;
        }
        else if (e.key === 'ArrowLeft' && APP.audioElement) {
            APP.audioElement.currentTime -= 10;
        }
    });
}

function handleFile(file) {
    if(!file.type.startsWith('audio')) return;
    const audio = new Audio();
    audio.src = URL.createObjectURL(file);
    audio.loop = true;
    
    // Clean Filename (basic strip extension)
    const name = file.name.replace(/\.[^/.]+$/, "");
    
    // Update UI
    document.getElementById('trackName').innerText = name;
    
    // Update MPRIS / Media Session
    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({ 
            title: name, 
            artist: 'VISU Player' 
        });
    }
    
    startAudio(audio, true);
}

window.onload = init;
</script>
</body>
</html>
